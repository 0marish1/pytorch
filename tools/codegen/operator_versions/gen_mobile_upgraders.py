#!/usr/bin/env python3
import argparse
import json
import sys
from typing import List, Optional, Dict, Any
import os
import yaml


def load_yaml(upgrader_yaml_path):
    with open(upgrader_yaml_path, "rb") as yaml_file:
        return yaml.safe_load(yaml_file)

UPGRADER_CPP_SRC = """#pragma once
/**
 * Generated by gen_selected_mobile_ops_header.py
 */

 #pragma once

#include <ATen/core/ivalue.h>
#include <string>
#include <vector>

#include <torch/csrc/jit/serialization/import_export_helpers.h>
#include <unordered_map>

namespace torch {
namespace jit {
namespace mobile {

// fix inline
inline c10::IValue to_tuple_2(std::vector<c10::IValue> ivalues) {
  return c10::ivalue::Tuple::create(std::move(ivalues));
}

struct Upgrader {
  int min_version;
  int max_version;
  std::string upgrader_name;
  int index;
};

// From operator_versions.yaml
// const std::unordered_map<
//     std::string,
//     std::vector<std::pair<std::pair<int, int>, std::string>>>
//     operator_versions({
//         // The following are called from setup sections.
//         {std::string("aten::div_Tensor"),
//          std::vector{std::make_pair(
//              std::make_pair(0, 3),
//              std::string("aten::div_Tensor_0_3"))}},
//     });
const std::unordered_map<
    std::string,
    Upgrader>
    operator_versions({// The following are called from setup sections.
                       {std::string("aten::div_Tensor"),
                        Upgrader{0, 3, "aten::div_Tensor_0_3", 0}}});

// From upgraders.yaml
const std::vector<std::pair<std::string, c10::IValue>> upgraders = {
    // The following are called from setup sections.
    {"aten::div_Tensor_0_3",
     to_tuple_2(std::vector<c10::IValue>{
         //  instructions
         to_tuple_2(std::vector<c10::IValue>{
             to_tuple_2({"STOREN", 1, 2}), to_tuple_2({"LOAD", 1, 0}),
             to_tuple_2({"OP", 0, 0}),     to_tuple_2({"JF", 3, 0}),
             to_tuple_2({"LOADC", 1, 0}),  to_tuple_2({"JMP", 3, 0}),
             to_tuple_2({"LOAD", 2, 0}),   to_tuple_2({"OP", 0, 0}),
             to_tuple_2({"STORE", 3, 0}),  to_tuple_2({"MOVE", 3, 0}),
             to_tuple_2({"JF", 5, 0}),     to_tuple_2({"LOAD", 1, 0}),
             to_tuple_2({"LOAD", 2, 0}),   to_tuple_2({"OP", 1, 0}),
             to_tuple_2({"JMP", 5, 0}),    to_tuple_2({"LOAD", 1, 0}),
             to_tuple_2({"LOAD", 2, 0}),   to_tuple_2({"LOADC", 0, 0}),
             to_tuple_2({"OP", 2, 0}),     to_tuple_2({"STORE", 4, 0}),
             to_tuple_2({"DROPR", 2, 0}),  to_tuple_2({"DROPR", 1, 0}),
             to_tuple_2({"MOVE", 4, 0}),   to_tuple_2({"RET", 0, 0}),
         }),
         //  operators
         to_tuple_2(std::vector<c10::IValue>{
             to_tuple_2({"aten::is_floating_point", "", 1}),
             to_tuple_2({"aten::div", "Tensor", 2}),
             to_tuple_2({"aten::div", "Tensor_mode", 3}),
         }),
         //  constants
         to_tuple_2(std::vector<c10::IValue>{
             c10::IValue("trunc"),
             c10::IValue(true),
         }),
         //  types
         to_tuple_2(std::vector<c10::IValue>{

         }),
         //  register_size
         to_tuple_2(std::vector<c10::IValue>{
             4,
         }),
     })},
};

} // namespace mobile
} // namespace jit
} // namespace torch

"""

def write_cpp(cpp_path):
    print("writing file to : ", cpp_path + "/upgrader_codegen.h")
    with open(
        os.path.join(cpp_path, "upgrader_codegen.h"), "wb"
    ) as out_file:
        out_file.write(UPGRADER_CPP_SRC.encode("utf-8"))

def parse_upgrader(upgrader_yaml_path):
    upgrader_dict = load_yaml(upgrader_yaml_path)
    print("upgrader: ")
    print(upgrader_dict)
    for op_name, bytecode in upgrader_dict.items():
        print("op: ", op_name)
        for table_name, contents in bytecode.items():
            print("table name: ", table_name)
            for content in contents:
                print("content: ", content)


def get_parser_options(parser: argparse.ArgumentParser) -> argparse.Namespace:
    parser.add_argument(
        "--input_yaml",
        type=str,
        help="A path to input yaml file.",
        required=True,
    )
    parser.add_argument(
        "--output_path",
        help="Output mobile_upgrader.cpp.",
        required=True,
    )
    options = parser.parse_args()
    return options


def main(argv):
    parser = argparse.ArgumentParser(description="Generate used operators YAML")
    options = get_parser_options(parser)

    yaml_path = options.input_yaml
    output_path = options.output_path

    parse_upgrader(yaml_path)
    write_cpp(options.output_path)


if __name__ == "__main__":
    main(sys.argv)
